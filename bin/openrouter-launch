#!/usr/bin/env bash
#
# openrouter-launch - Launch AI coding tools with OpenRouter
# https://github.com/truefrontier/openrouter-launch
#
# Usage: openrouter-launch [OPTIONS] [INTEGRATION]
#

set -euo pipefail
[[ "${DEBUG:-0}" == "1" ]] && set -x

#######################################
# Constants
#######################################

readonly VERSION="0.5.0"
readonly CONFIG_DIR="$HOME/.openrouter-launch"
readonly CONFIG_FILE="$CONFIG_DIR/config"
readonly CACHE_DIR="$HOME/.cache/openrouter"
readonly CACHE_FILE="$CACHE_DIR/models.json"
readonly CACHE_TTL=3600  # 1 hour
readonly OPENROUTER_BASE_URL="https://openrouter.ai/api"

# Fallback model list (used when API fetch fails and no cache)
# Using indexed array for bash 3.x compatibility
FALLBACK_MODELS=(
    "anthropic/claude-sonnet-4|\$3/\$15 per 1M tokens"
    "anthropic/claude-opus-4|\$15/\$75 per 1M tokens"
    "anthropic/claude-haiku|\$0.25/\$1.25 per 1M tokens"
    "google/gemini-2.0-flash|\$0.10/\$0.40 per 1M tokens"
    "google/gemini-2.5-pro|\$1.25/\$10 per 1M tokens"
    "openai/gpt-4o|\$2.50/\$10 per 1M tokens"
    "openai/gpt-4o-mini|\$0.15/\$0.60 per 1M tokens"
    "deepseek/deepseek-chat-v3|\$0.14/\$0.28 per 1M tokens"
    "meta-llama/llama-3.3-70b-instruct|\$0.30/\$0.40 per 1M tokens"
    "qwen/qwen-2.5-coder-32b-instruct|\$0.20/\$0.20 per 1M tokens"
)

# Active model list (populated by load_models)
MODELS=()

# Optional dependency flag
HAS_JQ=0

# Refresh models flag
REFRESH_MODELS=0

#######################################
# Logging functions (to stderr)
#######################################

log_info() {
    echo "[INFO] $*" >&2
}

log_error() {
    echo "[ERROR] $*" >&2
}

log_success() {
    echo "✓ $*" >&2
}

#######################################
# Dependency validation
#######################################

check_dependencies() {
    local cmd
    for cmd in "$@"; do
        if ! command -v "$cmd" &>/dev/null; then
            log_error "Missing required command: $cmd"
            exit 1
        fi
    done
}

check_optional_dependencies() {
    if command -v jq &>/dev/null; then
        HAS_JQ=1
    else
        log_info "jq not found - using cached/fallback model list"
        log_info "Install jq for live model fetching: https://jqlang.github.io/jq/"
    fi
}

#######################################
# Model caching
#######################################

get_cache_mtime() {
    local file="$1"
    if [[ ! -f "$file" ]]; then
        echo "0"
        return
    fi
    case "$(uname -s)" in
        Darwin)
            stat -f %m "$file" 2>/dev/null || echo "0"
            ;;
        *)
            stat -c %Y "$file" 2>/dev/null || echo "0"
            ;;
    esac
}

is_cache_valid() {
    if [[ ! -f "$CACHE_FILE" ]]; then
        return 1
    fi
    local mtime
    local now
    mtime=$(get_cache_mtime "$CACHE_FILE")
    now=$(date +%s)
    local age=$((now - mtime))
    [[ $age -lt $CACHE_TTL ]]
}

ensure_cache_dir() {
    if [[ ! -d "$CACHE_DIR" ]]; then
        mkdir -p "$CACHE_DIR"
    fi
}

#######################################
# Model fetching
#######################################

# List of popular coding models to filter by
# These are prioritized in the model list
CODING_MODEL_PREFIXES=(
    "anthropic/claude"
    "openai/gpt-4"
    "openai/o1"
    "openai/o3"
    "google/gemini"
    "deepseek/deepseek"
    "meta-llama/llama"
    "qwen/qwen"
    "mistralai/mistral"
    "mistralai/codestral"
    "x-ai/grok"
)

is_coding_model() {
    local model_id="$1"
    local prefix
    for prefix in "${CODING_MODEL_PREFIXES[@]}"; do
        if [[ "$model_id" == "$prefix"* ]]; then
            return 0
        fi
    done
    return 1
}

fetch_models() {
    if [[ $HAS_JQ -eq 0 ]]; then
        return 1
    fi

    log_info "Fetching models from OpenRouter..."

    local response
    response=$(curl -s --max-time 10 "https://openrouter.ai/api/v1/models" 2>/dev/null)

    if [[ -z "$response" ]]; then
        log_error "Failed to fetch models from API"
        return 1
    fi

    # Validate JSON response
    if ! echo "$response" | jq -e '.data' &>/dev/null; then
        log_error "Invalid API response"
        return 1
    fi

    # Parse models: filter for coding models, exclude free/preview, format pricing
    # Price is per token, convert to per 1M tokens
    local parsed
    parsed=$(echo "$response" | jq -r '
        .data
        | map(select(
            .id != null and
            .pricing.prompt != null and
            .pricing.completion != null and
            (.id | test(":free$") | not) and
            (.pricing.prompt | tonumber) >= 0
        ))
        | sort_by(.id)
        | .[]
        | {
            id: .id,
            prompt: ((.pricing.prompt | tonumber) * 1000000),
            completion: ((.pricing.completion | tonumber) * 1000000)
        }
        | "\(.id)|\(.prompt)|\(.completion)"
    ' 2>/dev/null)

    if [[ -z "$parsed" ]]; then
        log_error "Failed to parse model data"
        return 1
    fi

    # Save to cache file
    ensure_cache_dir
    echo "$parsed" > "$CACHE_FILE"
    log_success "Model list updated ($(echo "$parsed" | wc -l | tr -d ' ') models)"
    return 0
}

format_price() {
    local price="$1"
    # Format price nicely (e.g., 3.00 -> $3, 0.10 -> $0.10)
    if command -v awk &>/dev/null; then
        echo "$price" | awk '{
            if ($1 >= 1) {
                printf "$%.0f", $1
            } else if ($1 > 0) {
                printf "$%.2f", $1
            } else {
                printf "$0"
            }
        }'
    else
        printf "\$%.2f" "$price"
    fi
}

load_models_from_cache() {
    if [[ ! -f "$CACHE_FILE" ]]; then
        return 1
    fi

    MODELS=()
    local line
    local coding_models=()
    local other_models=()

    while IFS= read -r line; do
        [[ -z "$line" ]] && continue
        local id prompt completion
        id="${line%%|*}"
        local rest="${line#*|}"
        prompt="${rest%%|*}"
        completion="${rest#*|}"

        # Format pricing
        local prompt_fmt completion_fmt
        prompt_fmt=$(format_price "$prompt")
        completion_fmt=$(format_price "$completion")
        local entry="$id|$prompt_fmt/$completion_fmt per 1M tokens"

        # Categorize: coding models first
        if is_coding_model "$id"; then
            coding_models+=("$entry")
        else
            other_models+=("$entry")
        fi
    done < "$CACHE_FILE"

    # Combine: coding models first, limit to top 30 total
    local count=0
    for entry in "${coding_models[@]}"; do
        MODELS+=("$entry")
        ((count++))
        [[ $count -ge 30 ]] && break
    done

    # Add other models if we have room
    for entry in "${other_models[@]}"; do
        [[ $count -ge 30 ]] && break
        MODELS+=("$entry")
        ((count++))
    done

    [[ ${#MODELS[@]} -gt 0 ]]
}

load_models() {
    local force_refresh="${1:-0}"

    # Try cache first (if not forcing refresh)
    if [[ "$force_refresh" != "1" ]] && is_cache_valid; then
        if load_models_from_cache; then
            return 0
        fi
    fi

    # Try to fetch fresh data
    if [[ $HAS_JQ -eq 1 ]]; then
        if fetch_models; then
            if load_models_from_cache; then
                return 0
            fi
        fi
    fi

    # Try stale cache as fallback
    if [[ -f "$CACHE_FILE" ]]; then
        log_info "Using cached model list (may be outdated)"
        if load_models_from_cache; then
            return 0
        fi
    fi

    # Ultimate fallback: hardcoded list
    log_info "Using built-in model list"
    MODELS=("${FALLBACK_MODELS[@]}")
}

#######################################
# Model alias resolution
#######################################

resolve_alias() {
    local alias="$1"
    case "$alias" in
        sonnet|sonnet4)
            echo "anthropic/claude-sonnet-4"
            ;;
        opus|opus4)
            echo "anthropic/claude-opus-4"
            ;;
        haiku)
            echo "anthropic/claude-haiku"
            ;;
        flash)
            echo "google/gemini-2.0-flash"
            ;;
        gemini|gemini-pro)
            echo "google/gemini-2.5-pro"
            ;;
        gpt4|gpt4o)
            echo "openai/gpt-4o"
            ;;
        gpt4-mini|gpt4o-mini)
            echo "openai/gpt-4o-mini"
            ;;
        deepseek)
            echo "deepseek/deepseek-chat-v3"
            ;;
        llama|llama3)
            echo "meta-llama/llama-3.3-70b-instruct"
            ;;
        qwen|qwen-coder)
            echo "qwen/qwen-2.5-coder-32b-instruct"
            ;;
        *)
            # Not an alias, return as-is
            echo "$alias"
            ;;
    esac
}

# Check if model exists in MODELS array (or is a valid OpenRouter model format)
model_exists() {
    local model="$1"

    # First check loaded models
    if [[ ${#MODELS[@]} -gt 0 ]]; then
        local entry
        for entry in "${MODELS[@]}"; do
            local name="${entry%%|*}"
            if [[ "$name" == "$model" ]]; then
                return 0
            fi
        done
    fi

    # Also check fallback models
    local entry
    for entry in "${FALLBACK_MODELS[@]}"; do
        local name="${entry%%|*}"
        if [[ "$name" == "$model" ]]; then
            return 0
        fi
    done

    # Accept any model in provider/model format
    if [[ "$model" =~ ^[a-zA-Z0-9_-]+/[a-zA-Z0-9._-]+$ ]]; then
        return 0
    fi

    return 1
}

# Get model pricing
get_model_pricing() {
    local model="$1"
    local entry
    for entry in "${MODELS[@]}"; do
        local name="${entry%%|*}"
        local pricing="${entry#*|}"
        if [[ "$name" == "$model" ]]; then
            echo "$pricing"
            return 0
        fi
    done
    echo "unknown pricing"
}

# Resolve model (alias or full name) and validate
resolve_model() {
    local input="$1"
    local resolved

    # Try alias first
    resolved=$(resolve_alias "$input")

    # Check if it exists
    if model_exists "$resolved"; then
        echo "$resolved"
        return 0
    fi

    # Not found
    log_error "Unknown model: $input"
    log_error "Use --help to see available models and aliases"
    return 1
}

#######################################
# Model selection menu
#######################################

show_model_menu() {
    echo "" >&2
    echo "Select a model:" >&2
    echo "" >&2

    local i=1
    local entry
    for entry in "${MODELS[@]}"; do
        local name="${entry%%|*}"
        local pricing="${entry#*|}"
        printf "  %2d) %-40s %s\n" "$i" "$name" "$pricing" >&2
        ((i++))
    done

    echo "" >&2
}

select_model() {
    local selection
    local resolved

    # Load models before showing menu
    load_models "$REFRESH_MODELS"
    show_model_menu

    while true; do
        printf "Enter number (1-%d) or model name: " "${#MODELS[@]}" >&2
        read -r selection

        # Handle empty input
        if [[ -z "$selection" ]]; then
            log_error "Please enter a selection"
            continue
        fi

        # Check if it's a number
        if [[ "$selection" =~ ^[0-9]+$ ]]; then
            if [[ "$selection" -ge 1 && "$selection" -le "${#MODELS[@]}" ]]; then
                local entry="${MODELS[$((selection-1))]}"
                resolved="${entry%%|*}"
                break
            else
                log_error "Invalid selection. Enter 1-${#MODELS[@]}"
                continue
            fi
        fi

        # Try as model name or alias
        if resolved=$(resolve_model "$selection"); then
            break
        fi
    done

    echo "$resolved"
}

# Prompt to save model as default
maybe_save_default_model() {
    local model="$1"

    # Only prompt if we don't already have a default
    load_config
    if [[ -n "${DEFAULT_MODEL:-}" && "$DEFAULT_MODEL" == "$model" ]]; then
        return 0
    fi

    local save_it
    printf "Save '%s' as default model? [y/N]: " "$model" >&2
    read -r save_it

    if [[ "$save_it" =~ ^[Yy] ]]; then
        DEFAULT_MODEL="$model"
        save_config "$OPENROUTER_API_KEY" "$DEFAULT_MODEL"
    fi
}

#######################################
# Configuration management
#######################################

# Global state
OPENROUTER_API_KEY="${OPENROUTER_API_KEY:-}"
DEFAULT_MODEL="${DEFAULT_MODEL:-}"
DATA_COLLECTION="${DATA_COLLECTION:-deny}"
PROVIDER_SORT="${PROVIDER_SORT:-}"

load_config() {
    # Create config directory if needed
    if [[ ! -d "$CONFIG_DIR" ]]; then
        mkdir -p "$CONFIG_DIR"
        chmod 700 "$CONFIG_DIR"
    fi

    # Source config if exists
    if [[ -f "$CONFIG_FILE" ]]; then
        # shellcheck source=/dev/null
        source "$CONFIG_FILE"
    fi
}

save_config() {
    local key="$1"
    local default_model="${2:-}"

    # Write config file
    cat > "$CONFIG_FILE" << EOF
# openrouter-launch configuration
# Generated by openrouter-launch v$VERSION

OPENROUTER_API_KEY="$key"
DEFAULT_MODEL="$default_model"
DATA_COLLECTION="$DATA_COLLECTION"
PROVIDER_SORT="$PROVIDER_SORT"
EOF

    # Set secure permissions
    chmod 600 "$CONFIG_FILE"
    log_success "Configuration saved to $CONFIG_FILE"
}

#######################################
# API key management
#######################################

validate_api_key() {
    local key="$1"

    # Basic format validation
    if [[ ! "$key" =~ ^sk-or- ]]; then
        log_error "Invalid API key format (should start with 'sk-or-')"
        return 1
    fi

    # Validate against OpenRouter API
    log_info "Validating API key..."

    local response
    local http_code

    # Make request to OpenRouter API to validate key
    # Using /api/v1/auth/key endpoint which requires valid auth
    http_code=$(curl -s -o /dev/null -w "%{http_code}" \
        -H "Authorization: Bearer $key" \
        "https://openrouter.ai/api/v1/auth/key" 2>/dev/null)

    if [[ "$http_code" == "200" ]]; then
        log_success "API key validated successfully"
        return 0
    elif [[ "$http_code" == "401" ]]; then
        log_error "Invalid API key (authentication failed)"
        return 1
    elif [[ "$http_code" == "000" ]]; then
        log_error "Could not connect to OpenRouter API"
        log_error "Check your internet connection"
        return 1
    else
        log_error "Unexpected response from OpenRouter (HTTP $http_code)"
        return 1
    fi
}

prompt_api_key() {
    # Check if already set in environment
    if [[ -n "${OPENROUTER_API_KEY:-}" ]]; then
        log_info "Using API key from environment"
        return 0
    fi

    # Check if set in config
    load_config
    if [[ -n "${OPENROUTER_API_KEY:-}" ]]; then
        log_info "Using API key from config"
        return 0
    fi

    # Prompt for key
    echo "" >&2
    echo "OpenRouter API key not found." >&2
    echo "Get your key at: https://openrouter.ai/keys" >&2
    echo "" >&2

    local key
    while true; do
        printf "Enter your OpenRouter API key: " >&2
        read -r key

        if [[ -z "$key" ]]; then
            log_error "API key is required"
            continue
        fi

        if validate_api_key "$key"; then
            OPENROUTER_API_KEY="$key"
            break
        fi
    done

    # Ask to save
    local save_it
    printf "Save API key to config? [Y/n]: " >&2
    read -r save_it
    if [[ -z "$save_it" || "$save_it" =~ ^[Yy] ]]; then
        save_config "$OPENROUTER_API_KEY" "${DEFAULT_MODEL:-}"
    fi
}

#######################################
# Claude Code launch
#######################################

check_claude_installed() {
    if ! command -v claude &>/dev/null; then
        log_error "Claude Code not found"
        log_error "Install it from: https://docs.anthropic.com/en/docs/claude-code"
        exit 1
    fi
}

check_aider_installed() {
    if ! command -v aider &>/dev/null; then
        log_error "Aider not found"
        log_error "Install it from: https://aider.chat/docs/install.html"
        exit 1
    fi
}

check_opencode_installed() {
    if ! command -v opencode &>/dev/null; then
        log_error "OpenCode not found"
        log_error "Install it from: https://github.com/opencode-ai/opencode"
        exit 1
    fi
}

launch_claude() {
    local model="$1"
    shift  # Remove model from args, rest are passthrough

    check_claude_installed

    # Set environment variables for Claude Code
    export ANTHROPIC_BASE_URL="$OPENROUTER_BASE_URL"
    export ANTHROPIC_API_KEY=""
    export ANTHROPIC_AUTH_TOKEN="$OPENROUTER_API_KEY"

    # Set model override if not using default Anthropic model
    if [[ -n "$model" ]]; then
        export ANTHROPIC_MODEL="$model"
    fi

    echo "" >&2
    echo "Launching Claude Code with OpenRouter..." >&2
    echo "  Model: $model" >&2
    echo "  Base URL: $OPENROUTER_BASE_URL" >&2
    echo "  Data collection: $DATA_COLLECTION" >&2
    if [[ -n "$PROVIDER_SORT" ]]; then
        echo "  Provider sort: $PROVIDER_SORT" >&2
    fi
    echo "" >&2

    # Note: Provider preferences (data_collection, sort) require request body modifications.
    # Claude Code's Anthropic SDK doesn't support custom request body fields.
    # These preferences are saved for future integration support.
    # For now, you can set account-wide preferences at: https://openrouter.ai/settings/privacy

    # Execute Claude with any additional arguments
    exec claude "$@"
}

#######################################
# Aider launch
#######################################

launch_aider() {
    local model="$1"
    shift  # Remove model from args, rest are passthrough

    check_aider_installed

    # Aider uses OPENROUTER_API_KEY directly
    export OPENROUTER_API_KEY="$OPENROUTER_API_KEY"

    # Aider uses openrouter/<model> format for model selection
    local aider_model="openrouter/$model"

    echo "" >&2
    echo "Launching Aider with OpenRouter..." >&2
    echo "  Model: $aider_model" >&2
    echo "  Data collection: $DATA_COLLECTION" >&2
    if [[ -n "$PROVIDER_SORT" ]]; then
        echo "  Provider sort: $PROVIDER_SORT" >&2
    fi
    echo "" >&2

    # Execute Aider with model and any additional arguments
    exec aider --model "$aider_model" "$@"
}

#######################################
# OpenCode launch
#######################################

launch_opencode() {
    local model="$1"
    shift  # Remove model from args, rest are passthrough

    check_opencode_installed

    # OpenCode uses OPENROUTER_API_KEY directly
    # When set, it auto-detects and uses OpenRouter as the provider
    export OPENROUTER_API_KEY="$OPENROUTER_API_KEY"

    echo "" >&2
    echo "Launching OpenCode with OpenRouter..." >&2
    echo "  Model: $model" >&2
    echo "  Data collection: $DATA_COLLECTION" >&2
    if [[ -n "$PROVIDER_SORT" ]]; then
        echo "  Provider sort: $PROVIDER_SORT" >&2
    fi
    echo "" >&2
    echo "Note: OpenCode may use its own default OpenRouter models" >&2
    echo "      unless you configure ~/.opencode.json with your preferred model." >&2
    echo "" >&2

    # Execute OpenCode with any additional arguments
    exec opencode "$@"
}

#######################################
# Help and version
#######################################

show_version() {
    echo "openrouter-launch version $VERSION"
}

show_usage() {
    cat <<EOF
openrouter-launch - Launch AI coding tools with OpenRouter

USAGE:
    openrouter-launch [OPTIONS] [INTEGRATION]

INTEGRATIONS:
    claude          Launch Claude Code (default)
    aider           Launch Aider (https://aider.chat)
    opencode, oc    Launch OpenCode (https://github.com/opencode-ai/opencode)

OPTIONS:
    -m, --model MODEL    Use specific model (name or alias)
    -k, --key KEY        Use API key (overrides saved key)
    --save-default       Save the selected model as default
    --refresh-models     Force refresh model list from API
    --allow-data-collection
                         Allow providers to collect/train on data (default: deny)
    --sort ORDER         Provider sort order: price|throughput|latency
    -h, --help           Show this help message
    -v, --version        Show version information

MODEL ALIASES:
    sonnet    → anthropic/claude-sonnet-4
    opus      → anthropic/claude-opus-4
    haiku     → anthropic/claude-haiku
    flash     → google/gemini-2.0-flash
    gpt4      → openai/gpt-4o

PROVIDER PREFERENCES:
    By default, openrouter-launch denies data collection by AI providers.
    Use --allow-data-collection to allow providers that may store/train on data.
    Use --sort to prioritize providers by price, throughput, or latency.

    Note: Provider preferences are stored in config but require OpenRouter
    account settings for enforcement. Set at: https://openrouter.ai/settings/privacy

EXAMPLES:
    openrouter-launch                    # Interactive mode (launches Claude)
    openrouter-launch claude             # Launch Claude Code
    openrouter-launch claude -m sonnet   # Use Claude Sonnet with Claude Code
    openrouter-launch aider -m sonnet    # Launch Aider with Claude Sonnet
    openrouter-launch opencode           # Launch OpenCode
    openrouter-launch oc                 # Launch OpenCode (short alias)
    openrouter-launch -m flash           # Use Gemini Flash
    openrouter-launch --sort price       # Prefer cheapest providers
    openrouter-launch --allow-data-collection  # Allow data collection

CONFIG:
    Settings saved to: $CONFIG_FILE

For more information: https://openrouter.ai/docs
EOF
}

#######################################
# Main entry point
#######################################

main() {
    local selected_model=""
    local override_key=""
    local integration=""
    local save_default=0
    local passthrough_args=()

    # Parse arguments first (before dependency checks so --help always works)
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_usage
                exit 0
                ;;
            -v|--version)
                show_version
                exit 0
                ;;
            -m|--model)
                if [[ -z "${2:-}" ]]; then
                    log_error "Option $1 requires an argument"
                    exit 1
                fi
                selected_model=$(resolve_model "$2") || exit 1
                shift 2
                ;;
            -k|--key)
                if [[ -z "${2:-}" ]]; then
                    log_error "Option $1 requires an argument"
                    exit 1
                fi
                override_key="$2"
                shift 2
                ;;
            --save-default)
                save_default=1
                shift
                ;;
            --refresh-models)
                REFRESH_MODELS=1
                shift
                ;;
            --allow-data-collection)
                DATA_COLLECTION="allow"
                shift
                ;;
            --sort)
                if [[ -z "${2:-}" ]]; then
                    log_error "Option $1 requires an argument (price|throughput|latency)"
                    exit 1
                fi
                case "$2" in
                    price|throughput|latency)
                        PROVIDER_SORT="$2"
                        ;;
                    *)
                        log_error "Invalid sort order: $2 (must be price|throughput|latency)"
                        exit 1
                        ;;
                esac
                shift 2
                ;;
            claude)
                integration="claude"
                shift
                ;;
            aider)
                integration="aider"
                shift
                ;;
            opencode|oc)
                integration="opencode"
                shift
                ;;
            --)
                shift
                passthrough_args+=("$@")
                break
                ;;
            -*)
                log_error "Unknown option: $1"
                show_usage
                exit 1
                ;;
            *)
                # Unknown positional arg - treat as passthrough
                passthrough_args+=("$1")
                shift
                ;;
        esac
    done

    # Check dependencies
    check_dependencies curl
    check_optional_dependencies

    # Handle API key
    if [[ -n "$override_key" ]]; then
        if ! validate_api_key "$override_key"; then
            exit 1
        fi
        OPENROUTER_API_KEY="$override_key"
    else
        prompt_api_key
    fi

    # Handle model selection
    if [[ -z "$selected_model" ]]; then
        # Check for default model in config
        load_config
        if [[ -n "${DEFAULT_MODEL:-}" ]]; then
            log_info "Using default model: $DEFAULT_MODEL"
            selected_model="$DEFAULT_MODEL"
        else
            selected_model=$(select_model)
        fi
    fi

    # Save as default only if explicitly requested via --save-default flag
    if [[ $save_default -eq 1 ]]; then
        DEFAULT_MODEL="$selected_model"
        save_config "$OPENROUTER_API_KEY" "$DEFAULT_MODEL"
    fi

    # Default to Claude integration
    integration="${integration:-claude}"

    # Launch based on integration
    case "$integration" in
        claude)
            launch_claude "$selected_model" ${passthrough_args[@]+"${passthrough_args[@]}"}
            ;;
        aider)
            launch_aider "$selected_model" ${passthrough_args[@]+"${passthrough_args[@]}"}
            ;;
        opencode)
            launch_opencode "$selected_model" ${passthrough_args[@]+"${passthrough_args[@]}"}
            ;;
        *)
            log_error "Unknown integration: $integration"
            log_error "Supported: claude, aider, opencode"
            exit 1
            ;;
    esac
}

main "$@"
